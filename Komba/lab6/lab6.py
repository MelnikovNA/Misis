'''
АВЛ-дерево – это такое дерево поиска, где для любого узла высоты левого и
правого поддеревьев различается не более, чем на 1

Алгоритм «вставка в АВЛ-дерево»
Шаг 1: Ищется узел, куда можно вставить новый элемент так, чтобы его ключ не нарушал
принцип построения дерева поиска
Шаг 2: Проверка – разбалансировалось АВЛ-дерево или нет путём проверки «снизу»
Шаг 3: Находится первый узел «снизу», где произошло разбалансирование – опорный узел
Шаг 4: Производится балансировка АВЛ-дерева от опорного узла и ниже

Балансировка АВЛ-дерева
Мнемоническое правило:
• Добавление в левое поддерево левого сына опорного
узла – делаем правый поворот
• Добавление в правое поддерево правого сына
опорного узла – делаем левый поворот
• Добавление в левое поддерево правого сына
опорного узла – делаем правый-левый поворот
• Добавление в правое поддерево левого сына
опорного узла – делаем левый-правый поворот

Алгоритм добавления и балансировки АВЛ-дерева
Шаг 1: Ищется узел, куда можно вставить новый элемент так, чтобы его ключ не нарушал
принцип построения дерева поиска
Шаг 2: Проверка – разбалансировалось АВЛ-дерево или нет путём проверки «снизу» от
вставленного узла, для этого вычисляем (обновляем) балансы по пути. Критерий
разбалансировки – значение баланса по модулю 2 в каком-то узле
Шаг 3: Находится первый узел «снизу», где произошло разбалансирование – фиксируем
опорный узел
Шаг 4: По отношению к опорному узлу проводим анализ ситуации по мнемоническому
правилу
Шаг 5: По этому правилу выбираем схему поворота и реализуем его
Шаг 6: Заново вычисляем все балансы в узлах и проверяем, что их значение по модулю
меньше 2
Структура АВЛ-узла: [ключ, указатель на левое поддерево, указатель на правое
поддерево, указатель на родительский узел, значение баланса ]


Самобалансирующееся дерево
СБД – дерево поиска, где определена операция splay(k, T), где k - ключ, а T –
бинарное дерево поиска
splay(k, T) – операция, перемещающая узел с ключом k в корень дерева, при этом:
• если узел с ключом k присутствует в дереве, то он перемещается в корень
• если узел с ключом k отсутствует в дереве, то в корень перемещается либо его
предшественник, либо последователь
• перемещение осуществляется путём сбалансированных поворотов
Структура СБД-узла: [ключ; указатель на левое поддерево; указатель на правое
поддерево; указатель на родительский узел]
'''

# Класс для узла АВЛ-дерева
class AVLNode:
    def __init__(self, key, parent=None):
        self.key = key  # Ключ узла
        self.left = None  # Левый потомок
        self.right = None  # Правый потомок
        self.parent = parent  # Родитель узла
        self.height = 1  # Высота узла (по умолчанию 1, т.к. новый узел является листом)

# Класс для АВЛ-дерева
class AVLTree:
    def __init__(self):
        self.root = None  # Корень дерева, изначально пустой

    # Метод для получения высоты узла
    def get_height(self, node):
        return node.height if node else 0  # Если узел существует, возвращаем его высоту, иначе 0

    # Метод для вычисления баланса узла
    def get_balance(self, node):
        if not node:  # Если узел пустой, баланс равен 0
            return 0
        return self.get_height(node.left) - self.get_height(node.right)  # Разница высот левого и правого поддеревьев

    # Правый поворот вокруг узла y
    def rotate_right(self, y):
        x = y.left  # Узел, который станет новым корнем поддерева
        T = x.right  # Поддерево, которое временно переместится

        # Выполнение поворота
        x.right = y
        y.left = T

        # Обновление высот узлов после поворота
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))

        return x  # Возвращаем новый корень поддерева

    # Левый поворот вокруг узла x
    def rotate_left(self, x):
        y = x.right  # Узел, который станет новым корнем поддерева
        T = y.left  # Поддерево, которое временно переместится

        # Выполнение поворота
        y.left = x
        x.right = T


        # Обновление высот узлов после поворота
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))

        return y  # Возвращаем новый корень поддерева

    # Вставка нового узла в дерево
    def insert(self, root, key):
        if not root:  # Если текущий узел пустой, создаем новый узел с заданным ключом
            return AVLNode(key)

        if key < root.key:  # Если ключ меньше текущего узла, идем в левое поддерево
            root.left = self.insert(root.left, key)
            root.left.parent = root  # Устанавливаем родителя для нового узла
        else:  # Если ключ больше или равен текущему, идем в правое поддерево
            root.right = self.insert(root.right, key)
            root.right.parent = root  # Устанавливаем родителя для нового узла

        # Обновляем высоту текущего узла
        root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))

        # Проверяем баланс узла после вставки
        balance = self.get_balance(root)

        # Левый-левый случай (выполняем правый поворот)
        if balance > 1 and key < root.left.key:
            return self.rotate_right(root)

        # Правый-правый случай (выполняем левый поворот)
        if balance < -1 and key > root.right.key:
            return self.rotate_left(root)

        # Левый-правый случай (выполняем сначала левый, затем правый поворот)
        if balance > 1 and key > root.left.key:
            root.left = self.rotate_left(root.left)
            return self.rotate_right(root)

        # Правый-левый случай (выполняем сначала правый, затем левый поворот)
        if balance < -1 and key < root.right.key:
            root.right = self.rotate_right(root.right)
            return self.rotate_left(root)

        return root  # Возвращаем узел (возможно уже сбалансированный)

    # Добавление нового элемента в дерево
    def add(self, key):
        self.root = self.insert(self.root, key)  # Вставляем новый узел в дерево начиная с корня

    # Рекурсивный метод для печати дерева в консоли
    def print_tree(self, node, level=0, prefix="Root: "):
        if node is not None:  # Если узел существует
            print(" " * (level * 4) + prefix + str(node.key))  # Выводим текущий узел с отступами
            if node.left or node.right:  # Если есть потомки, рекурсивно вызываем функцию для них
                self.print_tree(node.left, level + 1, prefix="L--- ")  # Левый потомок
                self.print_tree(node.right, level + 1, prefix="R--- ")  # Правый потомок

# Пример использования
avl = AVLTree()  # Создаем пустое АВЛ-дерево

# Добавляем элементы в дерево
for key in [8, 4, 13, 2, 7, 9, 14, 0, 3, 6, 11, 5]:
    avl.add(key)  # Вставляем каждый элемент в дерево

# Вывод дерева в консоль
avl.print_tree(avl.root)  # Печатаем дерево, начиная с корня



'''

Когда происходит проверка баланса?
Проверка баланса происходит после вставки узла в дерево. После добавления нового элемента в дерево обновляется высота текущего узла и вычисляется баланс. Это делается на каждом уровне дерева, начиная с узла, куда была произведена вставка, и поднимаясь к корню дерева.

Какой элемент нужно проверить?
Необходимо проверить ветку, в которую был вставлен новый элемент. Конкретно, проверяются узлы на пути от нового элемента до корня дерева. Находится первый узел, где баланс вышел за пределы допустимого значения (баланс по модулю больше 1), и выполняется соответствующий поворот для восстановления баланса.

Структура АВЛ-узла:

[ключ, левый потомок, правый потомок, родитель, высота]
Пример узла:



[ключ=7, левый=6, правый=8, родитель=4, высота=2]
Как понять, в какое поддерево встанет пятёрка?
Чтобы понять, в какое поддерево встанет элемент 5:

Сравниваем 5  ключом текущего узла, начиная с корня.
Если 5 меньше ключа текущего узла, идем в левое поддерево.
Если 5 больше ключа текущего узла, идем в правое поддерево.
Повторяем процесс, пока не найдем подходящее пустое место.
Для элемента 5 в данном примере:


Начинаем с корня 8. Так как 5 < 8, идем в левое поддерево (4).
У узла 4: 5 > 4, идем в правое поддерево (7).
У узла 7: 5 < 7, идем в левое поддерево (6).
У узла 6: 5 < 6, вставляем 5 в левое поддерево 6.
'''